{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.inRangeOfSector = exports.formatAngleOfSector = exports.getAngleOfPoint = exports.distanceBetweenPoints = exports.formatAxisMap = exports.getMaxRadius = exports.polarToCartesian = exports.radianToDegree = exports.degreeToRadian = exports.RADIAN = void 0;\n\nvar _isNil2 = _interopRequireDefault(require(\"lodash/isNil\"));\n\nvar _DataUtils = require(\"./DataUtils\");\n\nvar _ChartUtils = require(\"./ChartUtils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nvar RADIAN = Math.PI / 180;\nexports.RADIAN = RADIAN;\n\nvar degreeToRadian = function degreeToRadian(angle) {\n  return angle * Math.PI / 180;\n};\n\nexports.degreeToRadian = degreeToRadian;\n\nvar radianToDegree = function radianToDegree(angleInRadian) {\n  return angleInRadian * 180 / Math.PI;\n};\n\nexports.radianToDegree = radianToDegree;\n\nvar polarToCartesian = function polarToCartesian(cx, cy, radius, angle) {\n  return {\n    x: cx + Math.cos(-RADIAN * angle) * radius,\n    y: cy + Math.sin(-RADIAN * angle) * radius\n  };\n};\n\nexports.polarToCartesian = polarToCartesian;\n\nvar getMaxRadius = function getMaxRadius(width, height) {\n  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  };\n  return Math.min(Math.abs(width - (offset.left || 0) - (offset.right || 0)), Math.abs(height - (offset.top || 0) - (offset.bottom || 0))) / 2;\n};\n/**\n * Calculate the scale function, position, width, height of axes\n * @param  {Object} props     Latest props\n * @param  {Object} axisMap   The configuration of axes\n * @param  {Object} offset    The offset of main part in the svg element\n * @param  {Object} axisType  The type of axes, radius-axis or angle-axis\n * @param  {String} chartName The name of chart\n * @return {Object} Configuration\n */\n\n\nexports.getMaxRadius = getMaxRadius;\n\nvar formatAxisMap = function formatAxisMap(props, axisMap, offset, axisType, chartName) {\n  var width = props.width,\n      height = props.height;\n  var startAngle = props.startAngle,\n      endAngle = props.endAngle;\n  var cx = (0, _DataUtils.getPercentValue)(props.cx, width, width / 2);\n  var cy = (0, _DataUtils.getPercentValue)(props.cy, height, height / 2);\n  var maxRadius = getMaxRadius(width, height, offset);\n  var innerRadius = (0, _DataUtils.getPercentValue)(props.innerRadius, maxRadius, 0);\n  var outerRadius = (0, _DataUtils.getPercentValue)(props.outerRadius, maxRadius, maxRadius * 0.8);\n  var ids = Object.keys(axisMap);\n  return ids.reduce(function (result, id) {\n    var axis = axisMap[id];\n    var domain = axis.domain,\n        reversed = axis.reversed;\n    var range;\n\n    if ((0, _isNil2[\"default\"])(axis.range)) {\n      if (axisType === 'angleAxis') {\n        range = [startAngle, endAngle];\n      } else if (axisType === 'radiusAxis') {\n        range = [innerRadius, outerRadius];\n      }\n\n      if (reversed) {\n        range = [range[1], range[0]];\n      }\n    } else {\n      range = axis.range;\n      var _range = range;\n\n      var _range2 = _slicedToArray(_range, 2);\n\n      startAngle = _range2[0];\n      endAngle = _range2[1];\n    }\n\n    var _parseScale = (0, _ChartUtils.parseScale)(axis, chartName),\n        realScaleType = _parseScale.realScaleType,\n        scale = _parseScale.scale;\n\n    scale.domain(domain).range(range);\n    (0, _ChartUtils.checkDomainOfScale)(scale);\n    var ticks = (0, _ChartUtils.getTicksOfScale)(scale, _objectSpread({}, axis, {\n      realScaleType: realScaleType\n    }));\n\n    var finalAxis = _objectSpread({}, axis, {}, ticks, {\n      range: range,\n      radius: outerRadius,\n      realScaleType: realScaleType,\n      scale: scale,\n      cx: cx,\n      cy: cy,\n      innerRadius: innerRadius,\n      outerRadius: outerRadius,\n      startAngle: startAngle,\n      endAngle: endAngle\n    });\n\n    return _objectSpread({}, result, _defineProperty({}, id, finalAxis));\n  }, {});\n};\n\nexports.formatAxisMap = formatAxisMap;\n\nvar distanceBetweenPoints = function distanceBetweenPoints(point, anotherPoint) {\n  var x1 = point.x,\n      y1 = point.y;\n  var x2 = anotherPoint.x,\n      y2 = anotherPoint.y;\n  return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\n};\n\nexports.distanceBetweenPoints = distanceBetweenPoints;\n\nvar getAngleOfPoint = function getAngleOfPoint(_ref, _ref2) {\n  var x = _ref.x,\n      y = _ref.y;\n  var cx = _ref2.cx,\n      cy = _ref2.cy;\n  var radius = distanceBetweenPoints({\n    x: x,\n    y: y\n  }, {\n    x: cx,\n    y: cy\n  });\n\n  if (radius <= 0) {\n    return {\n      radius: radius\n    };\n  }\n\n  var cos = (x - cx) / radius;\n  var angleInRadian = Math.acos(cos);\n\n  if (y > cy) {\n    angleInRadian = 2 * Math.PI - angleInRadian;\n  }\n\n  return {\n    radius: radius,\n    angle: radianToDegree(angleInRadian),\n    angleInRadian: angleInRadian\n  };\n};\n\nexports.getAngleOfPoint = getAngleOfPoint;\n\nvar formatAngleOfSector = function formatAngleOfSector(_ref3) {\n  var startAngle = _ref3.startAngle,\n      endAngle = _ref3.endAngle;\n  var startCnt = Math.floor(startAngle / 360);\n  var endCnt = Math.floor(endAngle / 360);\n  var min = Math.min(startCnt, endCnt);\n  return {\n    startAngle: startAngle - min * 360,\n    endAngle: endAngle - min * 360\n  };\n};\n\nexports.formatAngleOfSector = formatAngleOfSector;\n\nvar reverseFormatAngleOfSetor = function reverseFormatAngleOfSetor(angle, _ref4) {\n  var startAngle = _ref4.startAngle,\n      endAngle = _ref4.endAngle;\n  var startCnt = Math.floor(startAngle / 360);\n  var endCnt = Math.floor(endAngle / 360);\n  var min = Math.min(startCnt, endCnt);\n  return angle + min * 360;\n};\n\nvar inRangeOfSector = function inRangeOfSector(_ref5, sector) {\n  var x = _ref5.x,\n      y = _ref5.y;\n\n  var _getAngleOfPoint = getAngleOfPoint({\n    x: x,\n    y: y\n  }, sector),\n      radius = _getAngleOfPoint.radius,\n      angle = _getAngleOfPoint.angle;\n\n  var innerRadius = sector.innerRadius,\n      outerRadius = sector.outerRadius;\n\n  if (radius < innerRadius || radius > outerRadius) {\n    return false;\n  }\n\n  if (radius === 0) {\n    return true;\n  }\n\n  var _formatAngleOfSector = formatAngleOfSector(sector),\n      startAngle = _formatAngleOfSector.startAngle,\n      endAngle = _formatAngleOfSector.endAngle;\n\n  var formatAngle = angle;\n  var inRange;\n\n  if (startAngle <= endAngle) {\n    while (formatAngle > endAngle) {\n      formatAngle -= 360;\n    }\n\n    while (formatAngle < startAngle) {\n      formatAngle += 360;\n    }\n\n    inRange = formatAngle >= startAngle && formatAngle <= endAngle;\n  } else {\n    while (formatAngle > startAngle) {\n      formatAngle -= 360;\n    }\n\n    while (formatAngle < endAngle) {\n      formatAngle += 360;\n    }\n\n    inRange = formatAngle >= endAngle && formatAngle <= startAngle;\n  }\n\n  if (inRange) {\n    return _objectSpread({}, sector, {\n      radius: radius,\n      angle: reverseFormatAngleOfSetor(formatAngle, sector)\n    });\n  }\n\n  return null;\n};\n\nexports.inRangeOfSector = inRangeOfSector;","map":{"version":3,"sources":["/home/adrian/Escritorio/Miopers 2.0/web/node_modules/recharts/lib/util/PolarUtils.js"],"names":["Object","defineProperty","exports","value","inRangeOfSector","formatAngleOfSector","getAngleOfPoint","distanceBetweenPoints","formatAxisMap","getMaxRadius","polarToCartesian","radianToDegree","degreeToRadian","RADIAN","_isNil2","_interopRequireDefault","require","_DataUtils","_ChartUtils","obj","__esModule","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","configurable","writable","_slicedToArray","arr","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","TypeError","Symbol","iterator","prototype","toString","call","_arr","_n","_d","_e","undefined","_i","_s","next","done","err","Array","isArray","Math","PI","angle","angleInRadian","cx","cy","radius","x","cos","y","sin","width","height","offset","top","right","bottom","left","min","abs","props","axisMap","axisType","chartName","startAngle","endAngle","getPercentValue","maxRadius","innerRadius","outerRadius","ids","reduce","result","id","axis","domain","reversed","range","_range","_range2","_parseScale","parseScale","realScaleType","scale","checkDomainOfScale","ticks","getTicksOfScale","finalAxis","point","anotherPoint","x1","y1","x2","y2","sqrt","pow","_ref","_ref2","acos","_ref3","startCnt","floor","endCnt","reverseFormatAngleOfSetor","_ref4","_ref5","sector","_getAngleOfPoint","_formatAngleOfSector","formatAngle","inRange"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.inRangeOfSector = exports.formatAngleOfSector = exports.getAngleOfPoint = exports.distanceBetweenPoints = exports.formatAxisMap = exports.getMaxRadius = exports.polarToCartesian = exports.radianToDegree = exports.degreeToRadian = exports.RADIAN = void 0;\n\nvar _isNil2 = _interopRequireDefault(require(\"lodash/isNil\"));\n\nvar _DataUtils = require(\"./DataUtils\");\n\nvar _ChartUtils = require(\"./ChartUtils\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar RADIAN = Math.PI / 180;\nexports.RADIAN = RADIAN;\n\nvar degreeToRadian = function degreeToRadian(angle) {\n  return angle * Math.PI / 180;\n};\n\nexports.degreeToRadian = degreeToRadian;\n\nvar radianToDegree = function radianToDegree(angleInRadian) {\n  return angleInRadian * 180 / Math.PI;\n};\n\nexports.radianToDegree = radianToDegree;\n\nvar polarToCartesian = function polarToCartesian(cx, cy, radius, angle) {\n  return {\n    x: cx + Math.cos(-RADIAN * angle) * radius,\n    y: cy + Math.sin(-RADIAN * angle) * radius\n  };\n};\n\nexports.polarToCartesian = polarToCartesian;\n\nvar getMaxRadius = function getMaxRadius(width, height) {\n  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  };\n  return Math.min(Math.abs(width - (offset.left || 0) - (offset.right || 0)), Math.abs(height - (offset.top || 0) - (offset.bottom || 0))) / 2;\n};\n/**\n * Calculate the scale function, position, width, height of axes\n * @param  {Object} props     Latest props\n * @param  {Object} axisMap   The configuration of axes\n * @param  {Object} offset    The offset of main part in the svg element\n * @param  {Object} axisType  The type of axes, radius-axis or angle-axis\n * @param  {String} chartName The name of chart\n * @return {Object} Configuration\n */\n\n\nexports.getMaxRadius = getMaxRadius;\n\nvar formatAxisMap = function formatAxisMap(props, axisMap, offset, axisType, chartName) {\n  var width = props.width,\n      height = props.height;\n  var startAngle = props.startAngle,\n      endAngle = props.endAngle;\n  var cx = (0, _DataUtils.getPercentValue)(props.cx, width, width / 2);\n  var cy = (0, _DataUtils.getPercentValue)(props.cy, height, height / 2);\n  var maxRadius = getMaxRadius(width, height, offset);\n  var innerRadius = (0, _DataUtils.getPercentValue)(props.innerRadius, maxRadius, 0);\n  var outerRadius = (0, _DataUtils.getPercentValue)(props.outerRadius, maxRadius, maxRadius * 0.8);\n  var ids = Object.keys(axisMap);\n  return ids.reduce(function (result, id) {\n    var axis = axisMap[id];\n    var domain = axis.domain,\n        reversed = axis.reversed;\n    var range;\n\n    if ((0, _isNil2[\"default\"])(axis.range)) {\n      if (axisType === 'angleAxis') {\n        range = [startAngle, endAngle];\n      } else if (axisType === 'radiusAxis') {\n        range = [innerRadius, outerRadius];\n      }\n\n      if (reversed) {\n        range = [range[1], range[0]];\n      }\n    } else {\n      range = axis.range;\n      var _range = range;\n\n      var _range2 = _slicedToArray(_range, 2);\n\n      startAngle = _range2[0];\n      endAngle = _range2[1];\n    }\n\n    var _parseScale = (0, _ChartUtils.parseScale)(axis, chartName),\n        realScaleType = _parseScale.realScaleType,\n        scale = _parseScale.scale;\n\n    scale.domain(domain).range(range);\n    (0, _ChartUtils.checkDomainOfScale)(scale);\n    var ticks = (0, _ChartUtils.getTicksOfScale)(scale, _objectSpread({}, axis, {\n      realScaleType: realScaleType\n    }));\n\n    var finalAxis = _objectSpread({}, axis, {}, ticks, {\n      range: range,\n      radius: outerRadius,\n      realScaleType: realScaleType,\n      scale: scale,\n      cx: cx,\n      cy: cy,\n      innerRadius: innerRadius,\n      outerRadius: outerRadius,\n      startAngle: startAngle,\n      endAngle: endAngle\n    });\n\n    return _objectSpread({}, result, _defineProperty({}, id, finalAxis));\n  }, {});\n};\n\nexports.formatAxisMap = formatAxisMap;\n\nvar distanceBetweenPoints = function distanceBetweenPoints(point, anotherPoint) {\n  var x1 = point.x,\n      y1 = point.y;\n  var x2 = anotherPoint.x,\n      y2 = anotherPoint.y;\n  return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\n};\n\nexports.distanceBetweenPoints = distanceBetweenPoints;\n\nvar getAngleOfPoint = function getAngleOfPoint(_ref, _ref2) {\n  var x = _ref.x,\n      y = _ref.y;\n  var cx = _ref2.cx,\n      cy = _ref2.cy;\n  var radius = distanceBetweenPoints({\n    x: x,\n    y: y\n  }, {\n    x: cx,\n    y: cy\n  });\n\n  if (radius <= 0) {\n    return {\n      radius: radius\n    };\n  }\n\n  var cos = (x - cx) / radius;\n  var angleInRadian = Math.acos(cos);\n\n  if (y > cy) {\n    angleInRadian = 2 * Math.PI - angleInRadian;\n  }\n\n  return {\n    radius: radius,\n    angle: radianToDegree(angleInRadian),\n    angleInRadian: angleInRadian\n  };\n};\n\nexports.getAngleOfPoint = getAngleOfPoint;\n\nvar formatAngleOfSector = function formatAngleOfSector(_ref3) {\n  var startAngle = _ref3.startAngle,\n      endAngle = _ref3.endAngle;\n  var startCnt = Math.floor(startAngle / 360);\n  var endCnt = Math.floor(endAngle / 360);\n  var min = Math.min(startCnt, endCnt);\n  return {\n    startAngle: startAngle - min * 360,\n    endAngle: endAngle - min * 360\n  };\n};\n\nexports.formatAngleOfSector = formatAngleOfSector;\n\nvar reverseFormatAngleOfSetor = function reverseFormatAngleOfSetor(angle, _ref4) {\n  var startAngle = _ref4.startAngle,\n      endAngle = _ref4.endAngle;\n  var startCnt = Math.floor(startAngle / 360);\n  var endCnt = Math.floor(endAngle / 360);\n  var min = Math.min(startCnt, endCnt);\n  return angle + min * 360;\n};\n\nvar inRangeOfSector = function inRangeOfSector(_ref5, sector) {\n  var x = _ref5.x,\n      y = _ref5.y;\n\n  var _getAngleOfPoint = getAngleOfPoint({\n    x: x,\n    y: y\n  }, sector),\n      radius = _getAngleOfPoint.radius,\n      angle = _getAngleOfPoint.angle;\n\n  var innerRadius = sector.innerRadius,\n      outerRadius = sector.outerRadius;\n\n  if (radius < innerRadius || radius > outerRadius) {\n    return false;\n  }\n\n  if (radius === 0) {\n    return true;\n  }\n\n  var _formatAngleOfSector = formatAngleOfSector(sector),\n      startAngle = _formatAngleOfSector.startAngle,\n      endAngle = _formatAngleOfSector.endAngle;\n\n  var formatAngle = angle;\n  var inRange;\n\n  if (startAngle <= endAngle) {\n    while (formatAngle > endAngle) {\n      formatAngle -= 360;\n    }\n\n    while (formatAngle < startAngle) {\n      formatAngle += 360;\n    }\n\n    inRange = formatAngle >= startAngle && formatAngle <= endAngle;\n  } else {\n    while (formatAngle > startAngle) {\n      formatAngle -= 360;\n    }\n\n    while (formatAngle < endAngle) {\n      formatAngle += 360;\n    }\n\n    inRange = formatAngle >= endAngle && formatAngle <= startAngle;\n  }\n\n  if (inRange) {\n    return _objectSpread({}, sector, {\n      radius: radius,\n      angle: reverseFormatAngleOfSetor(formatAngle, sector)\n    });\n  }\n\n  return null;\n};\n\nexports.inRangeOfSector = inRangeOfSector;"]},"metadata":{},"sourceType":"script"}